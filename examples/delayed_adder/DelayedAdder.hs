import Clash.Prelude

import qualified Data.List as L


reg' :: Unsigned 1 -> Unsigned 1 -> (Unsigned 1, Unsigned 1)
reg' state input = (state', state)
    where state' = input

regB = mealy reg' 0

clone :: () -> Unsigned 1 -> ((), (Unsigned 1, Unsigned 1))
clone () input = ((), (input, input))

cloneB = mealy clone ()

add' :: () -> (Unsigned 1, Unsigned 1) -> ((), (Unsigned 2))
add' () (s1, s2) = ((), ((fromIntegral s2) + (fromIntegral s1)))

addB = mealy add' ()

-- generated by Click Clash:

system cloneIn0 = addOut0
    where

        (cloneOut0, cloneOut1) = unbundle $ cloneB cloneIn0
        addOut0 = addB $ bundle (cloneOut0, regOut0)
        regOut0 = regB cloneOut1

-- tests

test1 = mapM_ putStrLn $ L.map (\(a, b) -> show a L.++ " -> " L.++ show b) $ L.zip input output
    where
        output = simulate @System system input
        input = [0,0,0,0,1,0,0,0,1,1,1,1,1,0,0,0,0]